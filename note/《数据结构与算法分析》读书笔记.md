<h3>数据结构与算法分析</h3>

1.引论

	1）选择问题：设有一组N个数而要确定其中第K个最大者。
	
	2）数学知识复习：
		
		【1】常用公式
			指数、对数、级数、模运算
		【2】证明方法
			归纳法证明：【1】基准情况【2】归纳假设、通过反例证明、反证法证明、递归证明

	3）递归（recursive）四条法则
	
		【1】基本情形（base case）：基准的情形，不用递归就能求解。
		【2】不断推进（making progress）：对于要递归求解的情形，递归调用必须能够朝着一个基准情形推进。
		【3】设计法则：假设所有的递归调用都能运行。
		【4】合成效益法则（compound interest rule）：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

	4）泛型机制（generic mechanism）：如果除去对象的基本类型外，实现方法时相同的，就可以用泛型实现（generic implementation）来描述这种基本的功能。
	
		【1】注意
			<1> 只有实现Comparable接口的那些对象才能作为Comparable	数组的元素被传递。仅有compareTo方法但是并未宣传实现	Comparable接口的对象不是comparable的，不具有IS-A关系。
			<2> 如果Comparable数组有两个不相容的对象（例如String和Shape），那么ComparaTo方法将抛出CLassCastException。
			<3> 基本类型不能作为Comparable传递，但是包装类可以。
			<4> 接口究竟是不不是标准的库接口不是必需的。
		
		【2】自动装箱、拆箱		
		【3】菱形运算符
		【4】泛型static方法
		【5】类型限界
		【6】类型擦除

		【7】对于泛型的限制
			<1> 基本类型不能做参数类型
			<2> instanceof检测和类型转换工作只对原始类型进行
			<3> static的语境：在一个泛型类中，static方法和static域不可引用类的类型变量，因为在类型擦除后类型变量就不存在了。由于实际上只存在一个原始的类，因此static域在该类的泛型实例之间是共享的。
			<4> 不能创建一个泛型类型的实例。
			<5> 不能创建一个泛型的数组。
			<6> 参数化类型的数组：参数化类型的数组的实例化是非法的。

	

2.表，栈和队列

	1）抽象数据类型（abstract data type,ADT）：是带有一组操作的一些对象的集合。

	2）双链表（double linked list）：每一个节点不仅有后驱节点的链；，还有前驱节点的链。

	3）Java Collections API中的表
		【1】Collection接口：Collection接口扩展了Iterable接口,实现Iterable接口的那些类可以拥有增强的for循环，改循环用在在这些类上以观察他们所有的项。
		
		【2】Iterator接口：实Iterable接口的集合必须提供一个称为iterator的方法，该方法返回一个Iterator类型的对象。

		思路：通过Iterator方法，每个集合均可创建并返回给客户一个实现Iterator接口的对象，并将当前位置的概念在对象内部存储下来。


		remove（）方法：Iterator的remove（）方法的主要有点在于知道所要删除的项的准确位置，删除的开销很可能要小得多。Collection的remove（）方法必须首先找出要被删除的项。

	4）List接口、ArrayList类和LinkedList类
		【1】ArrayList：优点：get或set花费常数时间；缺点：插入和删除代价昂贵。
		【2】LinkedList：提供了List ADT的双链表实现。优点：插入和删除开销很小（假设变动项是已知的）；缺点：不容易做索引。

	5）栈（stack）
		【1】基本概念：栈顶-top、进栈-push、出栈-pop
		【2】实现：链表实现、数组实现
		【3】应用
			<1> 中缀表达式的计算：花费时间O(N),
			<2> 中缀到后缀的转换：
			<3> 方法调用：JVM基于栈实现

	6）队列（queue）
		【1】基本概念：入队-enqueue、出队-dequeue、队尾-rear、对头-front
		【2】应用：文件服务器


3.树

	1）二叉查找树（binary search tree）：大部分操作运行时间平均为O(logN)
	
	2)树的深度

	3）树的遍历

		【1】先序遍历（preorder traversal）
		【2】后序遍历(postorder traversal)
		【3】中序遍历（）

	4）二叉树（binary tree）：每个节点都不能多于两个儿子。

		【1】构造表达式树
			<1> 一次一个符号的读入表达式；
			<2> 如果符号是操作数，那么简历一个单节点树并将它推入栈中；
			<3> 如果符号是操作符，那么就从栈中弹出两棵树T1和T2（先弹出T1）并形成一棵新的树，该树的根就是操作符，它的左儿子、右儿子分别是T2和T1,然后将新树压入栈中。
	
	5）二叉查找树
		【1】性质：对于树中的每个节点X,它的左子树所有项的值小于X中的项，而它的右子树中所有的项值大于X中的项。
		【2】节点的插入操作：