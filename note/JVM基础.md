<h3>JAVA虚拟机基础</h3>
1.JRE由JAVA API和JVM组成，JVM通过类加载器（Class Loader）加类JAVA应用，并通过JAVA PAI执行。JVM可以在所有的硬件环境上执行JAVA字节码而无需调整JAVA的执行模式。

2.JVM的特性：

	1）基于栈（Stack-based）的虚拟机:比较流行的计算机处理器都是基于寄存器（register）架构
	2）符号应用（Symbolic reference）：除基本类型外的所有JAVA类型（类和接口）都是通过符号引用取得关联的，非显示的基于内存地址的引用。
	3）垃圾回收机制：类的实例显式创建，垃圾回收机制自动校徽。
	4）通过明确清晰基本类型确保平台无关性：C/C++等传统编程语言对于Int类型数据在同平台上会有不同的字节长度，JVM却通过明确的定义基本类型的字节长度来维持代码的平台兼容，做到与平台无关。
	5）网络字节序（Network byte order）:Java class文件的二进制表示使用的是基于网络的字节序。
	6）JAVA字节码：运行于JAVA语言与机器语言的中间语言，已达到WORKA的目的。JAVA字节码是部署JAVA程序的最小单元。


3.类加载:
	JAVA提供了动态的特性，只在运行时第一次遇到类加载时才会去加载和链接，而非在编译时加载它。JVM的类加载器负责类的动态加载过程。

	1）类加载器特点：
		【1】层次结构：按照父子关系的层次结构组织。Bootstrap类加载器处于层次结构顶层，是所有类加载器的父类。
		【2】代理模型：基于类加载器的层次结构组织结构，类加载器之间可以进行代理。一个类需要加载时会先请求父类加载器判断该类是否已经被加载，如果父类加载器加载了该类，则可以直接使用而无需再次加载。如果没有加载，才需要当前类加载器来加载此类。
		【3】可见性限制：子类加载器可以在父类加载器中获取类，反之则不行。
		【4】不能卸载：类加载器可以载入类却不能卸载它，但是可以通过删除类加载器的方法卸载类。



3.JAVA内存区域与内存溢出异常<br/>
	JAVA虚拟机在执行JAVA程序的过程中会把他所有的管理的内存划分为若干个不同的数据区域，这些区域有着各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

	运行时数据区（5个）：方法区、虚拟机栈、本地方法栈、堆、程序计数器
		1)Java 虚拟机栈（Java Virtual Machine Stacks）
			【1】 线程私有，生命周期与线程相同。

			【2】 每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出入口等信息。每一个方法被调用到执行完成都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

			【3】 局部变量所需的内存空间在编译期间完成分配。当线程请求的栈大于虚拟机允许的深度，抛出StackOverflowError；如果虚拟机栈动态扩展无法申请到内存，则抛出OutOfMemoryError异常。

		2）本地方法栈（Native Method Stacks）
			虚拟机栈为执行JAVA方法服务，本地方法栈为虚拟机用到的Native方法服务。

		3）JAVA堆（JAVA Heap）
			【1】 内存最大的一块，被所有线程共享，虚拟机启动时就被创建，唯一目的是存放对象实例。
			【2】 垃圾收集器管理的主要区域。
			【3】 物理不连续，逻辑连续即可。

		4)方法区（Method Area）
			【1】 线程共享内存区域。存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
			【2】 该部分内的内存回收主要是针对常量池的回收和对类型的卸载。
			
		  运行常量池（Running Man Constant Pool）
			方法区的一部分，用于存放编译期生成的各种字面量和符号引用，在类加载后存放到方法区的运行常量池中。	

		5)程序计数器（Program Counter Register）
			【1】 一块较小的内存空间，是当前线程所执行的字节码的行号显示器，通过改变计数器的值来选取下一条需要执行的字节码指令。
			【2】 虚拟机的多线程通过多线程轮流切换并分配处理器执行时间来实现，为了线程切换之后能恢复到正确的执行位置，每一个线程都要一个独立的程序计数器。
			【3】 执行Native方法时计数器值为空（Undefined），此区域是唯一一个虚拟机中没有规定OutOfMemoryError情况的区域。

	对象访问：主流访问方式两种：使用句柄和直接指针
	内存溢出异常（OutOfmemoryError）
		JAVA堆溢出、虚拟机和本地方法栈溢出、运行时常量池溢出、方法区溢出、本机直接内存溢出


4.垃圾收集器与内存分配策略
	垃圾回收：那些需要回收、什么时候回收、怎么回收

	1） 如何确定对象已经不被使用，可以回收？
		【1】引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时计数器+1；引用失效时计数器-1；任何时刻计数器为0的对象及时不可能再被使用的。JAVA中没采用计数算法，因为该方法很难解决对象之间的互相循环引用问题。

		【2】根搜索算法：通过一系列的名为"GC Roots"的对象作为起始点，从这些点开始向下搜索所走过的路径成为引用链（Reference Chain），当一个对象到GC Root没有任何引用链相连，则证明词对象不可用。

		JAVA中可作为GC Roots的对象包括以下几种：
			【1】虚拟机栈（栈帧中的本地变量表）中引用的对象
			【2】方法区中的类静态属性引用的对象
			【3】方法区中的产量引用的对象
			【4】本地方法栈中JNI（Native方法）的引用的对象。

	2）Reference：Strong Reference、Soft Reference、Weak Reference、Phantom Reference（虚引用）
		【1】 Strong Reference：在程序代码中普遍存在，类似"Object obj = new Object()"，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

		【2】 Soft Reference：还有用但不是必需的对象。在系统简要发生内存溢出异常之前这些对象会被列进回收范围之中并进行第二次回收。
		
		【3】 Weak Reference：比软引用强度弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。

		【4】 Phantom Reference：最弱的引用关系。一个对象是否有需引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。设置虚引用的目的就是在对象被收集器回收之前收到一个系统的通知。

	3） 如何确定对象需要回收（两次标记）
		【1】 对象在进行根搜索后发现没有雨与GC Roots相连接的引用链，会被标记第一次并且进行一次筛选。

		【2】 筛选的条件是此对象是否有必要执行finalize（）方法：当对象没有覆盖finalize（）方法或者该方法已经被虚拟机执行过，则没有必要执行。

		【3】 如果有必要执行finalize（）方法，对象会被放置在一个F-Queue队列中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。执行指虚拟机会触发这个方法，但不会承诺等待他运行结束。

		原因：如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环，将可能会导致F-Queue队列中的其他对象永久陷入等待状态，甚至导致整个内存回收系统崩溃。

		finalize（）是逃脱回收的最后一次机会，稍后GC会对F-Queue中的对象进行第二次小规模的标记。对象在finalize（）方法中重新与引用链上任何一个对象建立联系就会移除第二次标记。

	4）回收方法区
		永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类

		废弃常量判断：常量进入了常量池但是没有任何对象引用常量。

		无用类判断：
			【1】 该类所有的实例都已经被回收，JAVA堆中不存在该类的任何实例
			【2】 加载加载该类的ClassLoader已经被回收
			【3】 该类对应的java.lang.Class对象没有人格地方被引用，无法在任何地方通过反射访问该类的方法。

	5）垃圾收集算法
		【1】 标记-清除算法（Mark-Sweep）：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

		缺点：效率问题，空间问题

		【2】 复制算法（Copying）：将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，再把已使用过的内存空间一次清理掉。

		现在的商业虚拟机都采用复制算法来回收新生代。

		【3】 标记-整理算法：让所有存活的对象都向一端移动，让后直接清理掉边界以外的内存。

		【4】 分代收集算法：根据对象的存活时期的不同将内存划分为几块，一般把JAVA分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。


	6）垃圾收集器
		【1】 Serial收集器：最基本、历史最悠久、单线程、简单高效

		【2】 ParNew收集器：Serial的多线程版本，是运行在Server模式下的虚拟机中首选的新生代收集器

		【3】 Parallel Scavenge收集器：新生代收集器，使用复制算法、并行的多线程。目标为达到一个可控制的吞吐量

		【4】 Serial Old收集器：Serial的老年代版本，单线程、标记-整理算法

		【5】 Parallel Old收集器：Parallel Scavenge的老年代版本，使用多线程和标记-整理算法

		【6】 CMS（Concurrent Mark Sweep）：以获取最短回收停顿时间为目标的收集器，用于尤其重视服务的响应速度的应用。基于标记-清除算法。

			过程：
				CMS initial Mark（初始标记）：标记GC Roots能直接关联到的对象，速度很快
				CMS concurrent Mark（并发标记）：进行GC Roots Tracing的过程
				CMS remark：修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
				CMS concurrent sweep：

			CMS优点：并发收集、低停顿

			CMS缺点：
				<1>对CPU资源非常敏感，并发标记和并发清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，当对用户程序的影响就会显得少一些。
				<2>无法处理浮动垃圾
				<3>会产生大量空间碎片

		【7】 G1（Garbage First）收集器：当前最新进。与CMS相比有两个显著改进<1>基于标记-整理算法实现<2>非常精确的控制停顿，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒，几乎是实时JAVA（RTSJ）的垃圾收集器的特征。

		G1将这个JAVA堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次更根据允许的收集时间优先回收垃圾最多的区域。


	7）JAVA内存分配与回收策略
		【1】 对象优先在Eden分配
		【2】 大对象直接带入老年代：大对象指需要大量连续内存空间的JAVA对象。虚拟机提供一个-XX：PretenureSizeThreshold参数，令大于这个设置值得对象直接在老年代中分配，目的是为了避免在Eden区及两个Survivor区之间发生大量的内存拷贝。

		PretenureSizeThreshold参数只对Serial和ParNew两个收集器有效
		【3】 长期存活的对象将进入老年代：虚拟机给对象设置对象年龄计数器，增加到一定的程度（默认15岁），晋升到老年代

		【4】 动态对象年龄判断：如果在Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

		【5】 空间分配担保


5.类文件结构

	1）class文件结构
		【1】 class文件是一组以8位字节为基础单位的二进制流。JAVA虚拟机规范规定class文件采用类似于C语言节后提的伪结构来存储，伪结构只有两种数据类型：无符号数和表，class文件没有任何分割符号。
		无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节；可描述数字、索引引用、数量值，或者按照UTF-8编码构成的字符串值。
		表：有多个无符号数或其他作为数据项构成的符合数据类型，习惯以"_info"结尾。用于描述有层次关系的符合结构的数据，这个class实质上就是一张表。

		【2】 魔数：class文件的头4个字节称为Magic Number，唯一作用为确定文件是否能被虚拟机接收的class文件。第5和第6字节依次是Minor Version，第7和第8字节是Major Version。（JAVA版本号从45开始，JDK1.1之后每个JDK大版本发布向上+1）

		【3】 常量池：紧接着主次版本号之后是常量池入口。常量池的容量计数从1开始，其他的集合类型都从0开始。

		常量池主要存放两大类常量：Literal（字面量）和Symbolic References（符号引用），而Symbolic References属于编译原理概念，包括了：<1>Fully Qualified Name（类和接口的全限定名）、Descriptor（字段的名称和描述符）、方法的名称和描述符。常量池中每一个常量都是一个表。

		【4】 访问标志：常量池之后2个字节为access_flag。一共有32个标记位可以用，当前之定义了其中8个，没用到的全部为0。

		【5】 类索引、父类索引与接口索引集合：this_class、super_class都是一个u2类型的数据，interface是一组u2类型的数据的集合。Class文件中由这三项数据来确定类的继承关系。

		【6】 字段表集合：field_info用于描述接口或类中申明的变量。字段包括类级变量或实例级变量，但不包括方法内部声明的变量。

		【7】 方法表集合：结构->access_flag(访问标记)、name_index（名称索引）、descriptor_index（描述符索引）、attributes（属性表集合）

		【8】 属性表集合（sttribute_info）
			<1> Code属性：程序中的方法体内的代码经过JAVAC编译器处理后变成字节码指令存储在Code属性内。
			<2> Exceptions属性：列举出方法中可能抛出的受查异常（Checked Exceptions），也就是方法描述时throws关键字后面列举出的异常。
			<3> LineNumberTable属性：描述JAVA源码行号与字节码行号（字节码的偏移量）之间的关系。
			<4> LocalVariableTable属性：描述栈帧中局部变量表中的变量与JAVA源码中定义的变量之间的关系。
			<5> SourceFile属性：记录生成这个Class文件中源码文件的名称。
			<6>ConstantValue属性：通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量（类变量）才可以使用这项属性。
			<7>InnerClasses属性：记录内部类与宿主类之间的关联
			<8>Deprecated及Synthetic属性：都属于标记类型的布尔属性



6.虚拟机类加载机制

	1）生命周期
		【1】 Loading
		【2】 Verification
		【3】 Preparation
		【4】 Resolution
		【5】 Initialization
		【6】 Using
		【8】 Unloading

		Verification、Preparation、Resolution三部分被统称为Liking

		JAVA虚拟机严格规定了有且只有的四种需要对类进行初始化的情况：
		<1> 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令常见的JAVA场景：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
		<2>使用java.lang.reflece包的方法对类进行反射调用的时候
		<3>初始化一个类的时候，发现其父类还没有进行初始化，需要先触发父类的初始化
		<4>虚拟机启动时，用户指定一个要执行的任务（包括main()方法的那个类），虚拟机会最先初始化这个主类。

		这四种场景被称为对一个类的主动引用，除此之外的引用方法都不会触发初始化，称为被动引用。

	2）类加载过程
		【1】loading：loading是Class Loading的一个阶段，需完成三件事：
			<1>通过一个雷达饿全限定名来获取定义此类的二进制字节流
			<2>将字节流所代表的静态存储结构转化为方法区的运行时数据结构
			<3>在JAVA堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

		【2】Verification：确保Class文件中的字节流包含信息符合单前虚拟机的要求，并且不会危害虚拟机自身的安全。
			<1>文件格式验证：验证字节流是否符合Java文件格式规范，验证之后字节流才会进入内存的方法区存储。验证点：
				是否以魔数0xCAFEBABE开头
				主次版本号是否在当前虚拟机处理范围之内
				常量池中是否有不被支持的常量类型
				....
			<2>元数据验证：语义分析，对类的元数据信息进行语义校检，检查是否符合JAVA语言规范，验证点：
				是否有父类
				父类是否继承了不允许被继承的类
				不是抽象的类是否实现了父类或接口中要求实现的方法

			<3> 字节码验证：进行数据流和控流分析，保证被验证类的方法在运行时不会做出危害虚拟机安全的行为，比如：
				保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
				保证跳转指令不会跳到方法体以外的字节码指令上

			<4> 符号引用验证：解析时虚拟机将符号引用转化为直接引用，此时符号引用验证发生，确保解析动作能正常执行。验证点：
				符号引用中通过字符串描述的全限定名是否能找到对应的类
				在指定类中是否存在符合方法的字段描述符以简单名称所描述的方法和字段
				
		【3】 Preparation：正式为类变量分配内存并设置类变量初始值，内存将在方法区中进行分配。
		注意：此时进行内存分配的仅包括类的静态变量，初始值通常为数据类型的0值。

		【4】 Resolution：将常量池内的符号引用替换为直接引用的过程。主要针对类或接口、字段、类方法、接口方法四类符号引用进行。

		【5】 initialization：初始化阶段是执行类构造器<cinit>()方法的过程

	3）类加载器：通过一个类的全限定名来获取描述此类的二进制字节流
		【1】 分类
			<1>Bootstrap Classloader（启动类加载器）：负责将存放在<JAVA_HOME>\lib目录中或者被-Xbootclasspth参数所指定的路径中、并且是虚拟机识别的类库加载到虚拟机中。改加载器无法被JAVA程序直接引用。

			<2> Extension ClassLoader（扩张类加载器）：由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定路径中的所有类库。可被开发者直接使用。

			<3> Application ClassLoader（应用程序类加载器）：sun.misc.Launcher$AppClassLoader实现，是ClassLoader中getSystemClassLoader()方法的返回值，也称系统类加载器。负责加载用户类路径ClassPath上所指定的类库，可直接使用，默认加载器。

		【2】 Parents Delegation Model（双亲委派模型）：要求除了顶层启动类加载器外，其余的类加载器都要有自己的父类加载器。类加载器之间的关系不使用Inheritance（继承）而是使用Composition（组合）关系来复用父加载器的代码。


7.虚拟机字节码执行引擎（从模型的角度讲解虚拟机的方法调用和字节码执行）

	1）运行时栈帧结构
		【1】 Stack Frame：支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的Virtual Machine Stack的栈元素。
		【2】 每一个栈帧包括了局部变量表、操作守护栈、动态连接、方法返回地址和一些额外的附加信息。编译时栈帧的大小就已经确定。
		【3】 局部变量表：一组变量值存储的空间，用于存放方法参数和方法内部定义的局部变量。Class文件在方法Code属性的max_locals数据项中确定该方法所需分配的最大局部变量表的容量。最小单位：变量槽
		【4】 操作数栈：常称操作栈，元素可以使JAVA的任意一个数据类型。
		【5】 动态连接：内个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
		【6】 方法返回
			<1> Normal Method Invocation Completion
			<2> Abrupt Method Invocation Completion
		【7】 附加信息

	2）方法调用：唯一任务就是确定被调用方法的版本（即调用哪一个方法），不涉及方法的内部运行过程，不等同于方法执行。
		【1】 解析：将其中一部分符号引用转化为直接引用，并且这个方法的调用版本在运行期是不可改变的。
		【2】 分派
			<1> 静态分派
			<2> 动态分派
			<3> 单分派与多分派
			<4> 虚拟机动态分派的实现

	3）基于栈的字节码解释执行引擎
		【1】 解释执行
		【2】 基于栈的指令集与基于寄存器的指令集
		【3】 基于栈的解释器执行过程


8.类加载及执行子系统的案例与实践

	1） Tomcat目录结构
		<1> /common：类库可以被Tomcat和所有的Web应用程序共同使用
		<2> /server：类库可以被Tomcat使用，对所有的Web应用程序都不可见
		<3> /shared：类库可以被所有的Web应用程序共同使用，当对Tomcat不可见
		<4> /WebAPP/WEB_INF：类库仅仅可以被此Web应用程序使用，对Tomcat和其他的Web应用程序不可见。

	2） Tomcat自定义类加载器
		CommonClassLoader、CataniaClassLoader、SharedClassLoader、WebAppClassLoader

	【3】 OSGi（Open Service Gateway Initiative）

	【4】 字节码生成技术与动态代理技术：

	【5】 Java Backporting Tools：Java逆向移植工具，最为出色的是Retrotranslator

9.编译期优化

	1）编译：将*.java文件转化成*.class文件的过程

	2） Javac编译器，三个过程：解析与填充符号表过程、 插入式注解处理器的注解处理过程、分析与字节码生成过程
		【1】 解析与填充符号表过程
			<1> 词法、语法分析：将源码的字符流转变为标记集合（Token），由com.sun.tools.javac.parser.Scanner类来实现
			<2> 填充符号表：由一组符号地址和符号信息构成的表格，由com.sun.tools.javac.parser.Enter类来实现
			<3> 注解处理器：
			<4> 语义分析与字节码生成：语义分析后，编译器获得程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。语义分析主要是对机构上正确的源程序进行上下文有关性质的审查，如进行类型审查。（标注检查、数据及控制流分析、解语法糖、字节码生成）

		【2】 插入式注解处理器的注解处理过程

		【3】 分析与字节码生成过程

	3）Java语法糖
		【1】 泛型与类型擦除
		【2】 自动装箱、拆箱与遍历循环
		 *  Integer i1 = 100;
   			Integer i2 = 100;
  			Integer i3 = 200;
  			Integer i4 = 200;
  			System.out.println(i1==i2);  //true
  			System.out.println(i3==i4);  //false

  			1、i1和i2会进行自动装箱，执行了valueOf函数，它们的值在(-128,128]这个范围内，它们会拿到SMALL_VALUES数组里面的同一个对象SMALL_VALUES[228]，它们引用到了同一个Integer对象，所以它们肯定是相等的。

			2、i3和i4也会进行自动装箱，执行了valueOf函数，它们的值大于128，所以会执行new Integer(200)，也就是说它们会分别创建两个不同的对象，所以它们肯定不等。
		[3] 条件编译

10.运行期优化

	1）HotSpot虚拟机内的及时编译器
		【1】 解释器与编译器
		【2】 编译对象与触发条件
		【3】 编译过程
		【4】 查看与分析即时编译结果

	2）编译优化技术
		【1】 公共子表达式消除
		【2】 数组边界检查消除
		【3】 方法内联
		【4】 逃逸分析


11.Java内存模型与线程

	1）主内存与工作内存
	2）主内存与工作内存之间的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之间的实现细节，Java内存模型中规定了以下8个操作来完成：
		【1】 lock：作用于主内存的变量，把一个变量表示为一条线程独占的状态
		【2】 unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
		【3】 read：作用于主内存的变量，把一个变量的值从主内存传输到想成的工作内存中，以便以后load动作使用
		【4】 load：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时会执行这个操作
		【5】 assign：作用于工作内存中的变量，把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
		【6】 store：作用于工作内存中的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
		【7】 write：作用于主内存的变量，她store操作从工作内存中得到的值放入主内存的变量中

		执行以上操作必须满足的规则：
		【1】 read和load、store和write操作不允许单一出现
		【2】 不允许一个线程丢弃它的最近的assign操作，变量在工作内存中改变之后必须把改变化同步回主内存
		【3】 不允许一个线程无缘无故的把数据从线程的工作内存同步到主内存中（没有发生assign操作）
		【4】 一个新的变量只能在主内存中产生，不允许在工作内存中直接使用一个没有被初始化（load或assign）的变量（变量在user和者store之前必须有assign和load）
		【5】 同一变量在同一时刻只允许一条线线程对其lock，当lock可以被同一线程重复执行多次，多次执行lock后，必须执行相同次数的unlock操作才能解锁
		【6】 对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值
		【7】 一个变量如果没有被事先lock操作锁定，则不允许对他执行unlock操作；也不允许去unlock一个被其他线程锁定的变量
		【8】 对变量执行unlock操作前，必须先把此变量同步回主内存中（执行store和write）

	3）volatitle变量的特殊规则
		【1】 变量定义为volatitle后有两个特性：第一是保证变量低所有线程的可见性，可见性指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量则需要通过主内存来完成。
		【2】 线程内表现为串行的语义：Java中普通的变量仅仅会保证早该方法的执行过程中所有依赖赋值结果的地方都能获取正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。

	4）对long和double型变量的特殊规则
		【1】 虚拟机允许将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这个操作的原子性
		【2】 原子性（Atomicity）：操作不可中断，只有全部执行成功或者执行失败。Java内存模型使用read、load、assign、use、store和write六个操作来直接保证变量的原子性。
		【3】 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java中实现可见性的关键字有：synchronized、final、votatile。同步块的可见性由“第一个变量执行unlock操作之前，必须把此变量同步回主内存中（执行store和write操作）”这条规则获得。
		【3】 有序性（Ordering）：
			<1>指令重排序、工作内存与主内存同步延迟现象：一个线程中观察另一个线程，所有操作都是无序的

	5）先行发生原则（happens-before）：




	6）线程：CPU调度的基本单位
		【1】 实现方式：<1> 使用内核线程实现
					 <2> 使用用户线程实现
					 <3> 使用用户线程加轻量级进程混合实现

		【2】 Java线程调度
			<1> 协同式线程调度（Cooperative Threads-Scheduling）
			<2> 抢占式线程调度（Preemptive Threads-Scheduling）
		【3】 线程状态：New、Runable、Waiting、Timed Waiting、Blocked、Terminated


12.线程安全与锁优化

	1）线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行人格其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。

	2）Java语言中各种操作共享的数据分类：
		【1】 不可变（Immutable）：一定线程安全
		【2】 绝对线程安全：
		【3】 相对线程安全：通常意义上的线程安全。
		【4】 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全的使用。
		【5】 线程对立：值不管调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码

	3）线程安全的实现方法

		【1】 互斥同步（Mutual Exclusion & Synchronization）:最常见的一种并发正确性保障手段。
		【2】 非阻塞同步（Blocking Synchronization）
		【3】 无同步方案：天生线程安全，不需要同步方案
			<1> 可重入代码（Reentrant Code）：也叫纯代码（Pure Code）可以在执行的任何时刻中断，转而去执行另外一行代码（包括递归调用本身），而在控制权返回后，原来的程序不会出现任何错误。
			<2> 线程本地存储（Thread Local Storage）
	4）锁优化
		【1】 自旋锁与自适应自旋
		【2】 消除锁：虚拟机及时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除
		【3】 锁粗化：虚拟机探测到有一串零碎的操作都对同一对象加锁，将会把锁同步的范围扩展（粗化）到整个操作序列的外部。
		【4】 轻量级锁：
		【5】 偏向锁：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

